164 3
382083689
comment 0 0 1 0 0 3 0 0
`*打开左相机，序列号为“RW0003003013”，句柄设为AcqHandle1
打开左相机，序列号为“RW0003003013”，句柄设为AcqHandle1
open_framegrabber 0 0 16 1 0 1 0 0
`open_framegrabber ('GenICamTL', 0, 0, 0, 0, 0, 0, 'progressive', -1, 'default', -1, 'false', 'default', 'MER-115-30UC(RW0003003013)', 0, -1, AcqHandle1)
'GenICamTL'
0
0
0
0
0
0
'progressive'
-1
'default'
-1
'false'
'default'
'MER-115-30UC(RW0003003013)'
0
-1
AcqHandle1
comment 0 0 1 0 0 3 0 0
`*设置为白平衡自动调节  
设置为白平衡自动调节
set_framegrabber_param 0 0 3 0 0 1 0 0
`set_framegrabber_param (AcqHandle1, 'BalanceWhiteAuto', 'Continuous')
AcqHandle1
'BalanceWhiteAuto'
'Continuous'
comment 0 0 1 0 0 3 0 0
`*打开右相机，序列号为“RW0004003013”， 句柄设为AcqHandle2
打开右相机，序列号为“RW0004003013”， 句柄设为AcqHandle2
open_framegrabber 0 0 16 1 0 1 0 0
`open_framegrabber ('GenICamTL', 0, 0, 0, 0, 0, 0, 'progressive', -1, 'default', -1, 'false', 'default', 'MER-115-30UC(RW0004003013)', 0, -1, AcqHandle2)
'GenICamTL'
0
0
0
0
0
0
'progressive'
-1
'default'
-1
'false'
'default'
'MER-115-30UC(RW0004003013)'
0
-1
AcqHandle2
comment 0 0 1 0 0 3 0 0
`*设置为白平衡自动调节   
设置为白平衡自动调节
set_framegrabber_param 0 0 3 0 0 1 0 0
`set_framegrabber_param (AcqHandle2, 'BalanceWhiteAuto', 'Continuous')
AcqHandle2
'BalanceWhiteAuto'
'Continuous'
comment 0 0 1 0 0 6 0 0
* 

comment 0 0 1 0 0 3 0 0
`*采集图像
采集图像
grab_image_async 0 1 2 0 0 1 0 0
`grab_image_async (Image1, AcqHandle1, -1)
Image1
AcqHandle1
-1
grab_image_async 0 1 2 0 0 1 0 0
`grab_image_async (Image2, AcqHandle2, -1)
Image2
AcqHandle2
-1
comment 0 0 1 0 0 6 0 0
* 

comment 0 0 1 0 0 3 0 0
`*打开适合图像大小的窗口
打开适合图像大小的窗口
get_image_size 1 0 0 2 0 1 0 0
`get_image_size (Image1, Width, Height)
Image1
Width
Height
dev_open_window_fit_image 1 0 4 1 0 4 0 0
`dev_open_window_fit_image (Image1, 0, 0, Width/2, Height/2, WindowHandle1)
Image1
0
0
Width/2
Height/2
WindowHandle1
get_image_size 1 0 0 2 0 1 0 0
`get_image_size (Image2, Width, Height)
Image2
Width
Height
dev_open_window_fit_image 1 0 4 1 0 4 0 0
`dev_open_window_fit_image (Image1, Width/2, Height/2, Width/2, Height/2, WindowHandle2)
Image1
Width/2
Height/2
Width/2
Height/2
WindowHandle2
comment 0 0 1 0 0 6 0 0
* 

while 0 0 1 0 0 3 0 0
`while(1)
1
comment 0 0 1 0 1 3 0 0
`    *采集图像
采集图像
grab_image_async 0 1 2 0 1 1 0 0
`    grab_image_async (Image1, AcqHandle1, -1)
Image1
AcqHandle1
-1
grab_image_async 0 1 2 0 1 1 0 0
`    grab_image_async (Image2, AcqHandle2, -1)
Image2
AcqHandle2
-1
comment 0 0 1 0 1 6 0 0
`    

assign 0 0 1 1 1 3 0 0
`    Number1:=0
0
Number1
assign 0 0 1 1 1 3 0 0
`    Number2:=0
0
Number2
comment 0 0 1 0 1 6 0 0
`    

comment 0 0 1 0 1 3 0 0
`    *左相机提取桌面
左相机提取桌面
comment 0 0 1 0 1 3 0 0
`    * Image1为左相机拍摄图片，Image11 Image12 Image13分别为RGB通道图像，ImageResult11 ImageResult12 ImageResult13分别为HSV通道图像
Image1为左相机拍摄图片，Image11 Image12 Image13分别为RGB通道图像，ImageResult11 ImageResult12 ImageResult13分别为HSV通道图像
decompose3 1 3 0 0 1 1 0 0
`    decompose3 ( Image1, Image11, Image12, Image1)
Image1
Image11
Image12
Image1
trans_from_rgb 3 3 1 0 1 1 0 0
`    trans_from_rgb (Image11, Image12, Image13, ImageResult11, ImageResult12, ImageResult13, 'hsv')
Image11
Image12
Image13
ImageResult11
ImageResult12
ImageResult13
'hsv'
comment 0 0 1 0 1 3 0 0
`    *阈值分割，对S通道图像进行阈值分割，分割区域为0至100，分割结果为区域Region2 
阈值分割，对S通道图像进行阈值分割，分割区域为0至100，分割结果为区域Region2
threshold 1 1 2 0 1 1 0 0
`    threshold (ImageResult12, RegionT1,0,100)
ImageResult12
RegionT1
0
100
comment 0 0 1 0 1 3 0 0
`    *针对区域Region2进行腐蚀，腐蚀参数为3.5，参数值越大，腐蚀面积越大
针对区域Region2进行腐蚀，腐蚀参数为3.5，参数值越大，腐蚀面积越大
erosion_circle 1 1 1 0 1 1 0 0
`    erosion_circle (RegionT1, RegionErosionT1, 3.5)
RegionT1
RegionErosionT1
3.5
comment 0 0 1 0 1 3 0 0
`    *对腐蚀后的区域进行填充操作，使腐蚀出的不完整桌面填充为完整桌面
对腐蚀后的区域进行填充操作，使腐蚀出的不完整桌面填充为完整桌面
fill_up 1 1 0 0 1 1 0 0
`    fill_up (RegionErosionT1, RegionFillUpT1)
RegionErosionT1
RegionFillUpT1
comment 0 0 1 0 1 3 0 0
`    *区域联通。将不同的区域各自联通起来，作为形状选择的目标，不同区域用不同颜色表示
区域联通。将不同的区域各自联通起来，作为形状选择的目标，不同区域用不同颜色表示
connection 1 1 0 0 1 1 0 0
`    connection ( RegionFillUpT1, ConnectedRegionsT1)
RegionFillUpT1
ConnectedRegionsT1
comment 0 0 1 0 1 3 0 0
`    *选择桌面区域。因为桌子呈较大面积矩形，因此面积为40万到110万像素点，矩形度为0.6至1.
选择桌面区域。因为桌子呈较大面积矩形，因此面积为40万到110万像素点，矩形度为0.6至1.
select_shape 1 1 4 0 1 1 0 0
`    select_shape (ConnectedRegionsT1, SelectedRegionsT1, ['area','rectangularity'], 'and', [400000, 0.6], [1100000, 1])
ConnectedRegionsT1
SelectedRegionsT1
['area','rectangularity']
'and'
[400000, 0.6]
[1100000, 1]
comment 0 0 1 0 1 6 0 0
`   

comment 0 0 1 0 1 3 0 0
`    *左相机识别红色圆形目标
左相机识别红色圆形目标
comment 0 0 1 0 1 3 0 0
`    *提取桌面  将G通道的图像与桌面区域相减
提取桌面  将G通道的图像与桌面区域相减
reduce_domain 2 1 0 0 1 1 0 0
`    reduce_domain (Image12, SelectedRegionsT1, ImageReducedl1)
Image12
SelectedRegionsT1
ImageReducedl1
comment 0 0 1 0 1 3 0 0
`    *针对G通道进行阈值分割，分割范围为0~60
针对G通道进行阈值分割，分割范围为0~60
threshold 1 1 2 0 1 1 0 0
`    threshold (Image11, Regionl1,0,60) 
Image11
Regionl1
0
60
comment 0 0 1 0 1 3 0 0
`    *为填补阈值分割出的小孔，对分割结果进行膨胀，膨胀系数为2
为填补阈值分割出的小孔，对分割结果进行膨胀，膨胀系数为2
closing_circle 1 1 1 0 1 1 0 0
`    closing_circle (Regioln1, RegionClosingl1, 2)
Regioln1
RegionClosingl1
2
comment 0 0 1 0 1 3 0 0
`    *为将目标进一步与背景区分，对膨胀结果进行腐蚀，腐蚀系数为2
为将目标进一步与背景区分，对膨胀结果进行腐蚀，腐蚀系数为2
opening_circle 1 1 1 0 1 1 0 0
`    opening_circle (RegionClosingl1, RegionOpeningl1, 2)
RegionClosingl1
RegionOpeningl1
2
comment 0 0 1 0 1 3 0 0
`    *将第一次腐蚀结果的区域与H通道的结果相减，得到H通道一部分的区域图
将第一次腐蚀结果的区域与H通道的结果相减，得到H通道一部分的区域图
reduce_domain 2 1 0 0 1 1 0 0
`    reduce_domain (ImageResult11, RegionOpeningl1, ImageReducedg1)
ImageResult11
RegionOpeningl1
ImageReducedg1
comment 0 0 1 0 1 3 0 0
`    *再将该图进行第二次阈值分割，分割范围为0~70
再将该图进行第二次阈值分割，分割范围为0~70
threshold 1 1 2 0 1 1 0 0
`    threshold (ImageReducedgl1, Regionl2,0,70)
ImageReducedgl1
Regionl2
0
70
comment 0 0 1 0 1 3 0 0
`    *对二次分割图像再进行膨胀处理
对二次分割图像再进行膨胀处理
closing_circle 1 1 1 0 1 1 0 0
`    closing_circle (Regionl2, RegionClosingl2, 2)
Regionl2
RegionClosingl2
2
comment 0 0 1 0 1 3 0 0
`    *而后进行腐蚀处理
而后进行腐蚀处理
opening_circle 1 1 1 0 1 1 0 0
`    opening_circle (RegionClosingl2, RegionOpeningl2, 2)
RegionClosingl2
RegionOpeningl2
2
comment 0 0 1 0 1 3 0 0
`    *为填补可能出现的空洞，进行填充处理，最终得到红色的目标区域
为填补可能出现的空洞，进行填充处理，最终得到红色的目标区域
fill_up 1 1 0 0 1 1 0 0
`    fill_up (RegionOpeningl2, RegionFillUpl1)
RegionOpeningl2
RegionFillUpl1
connection 1 1 0 0 1 1 0 0
`    connection ( RegionFillUpl1, ConnectedRegions12)   
RegionFillUpl1
ConnectedRegions12
comment 0 0 1 0 1 3 0 0
`    *最终，通过面积与圆度的形状特征，得到红色圆形目标
最终，通过面积与圆度的形状特征，得到红色圆形目标
select_shape 1 1 4 0 1 1 0 0
`    select_shape (ConnectedRegions12, SelectedRegions_L, ['area','circularity'], 'and', [2000, 0.75], [11000, 1])
ConnectedRegions12
SelectedRegions_L
['area','circularity']
'and'
[2000, 0.75]
[11000, 1]
comment 0 0 1 0 1 6 0 0
`    

comment 0 0 1 0 1 3 0 0
`    *右相机提取桌面
右相机提取桌面
comment 0 0 1 0 1 3 0 0
`    * Image2为右相机拍摄图片，Image21 Image22 Image23分别为RGB通道图像，ImageResult21 ImageResult22 ImageResult23分别为HSV通道图像
Image2为右相机拍摄图片，Image21 Image22 Image23分别为RGB通道图像，ImageResult21 ImageResult22 ImageResult23分别为HSV通道图像
decompose3 1 3 0 0 1 1 0 0
`    decompose3 ( Image2, Image21, Image22, Image23)
Image2
Image21
Image22
Image23
trans_from_rgb 3 3 1 0 1 1 0 0
`    trans_from_rgb (Image21, Image22, Image23, ImageResult21, ImageResult22, ImageResult23, 'hsv')
Image21
Image22
Image23
ImageResult21
ImageResult22
ImageResult23
'hsv'
comment 0 0 1 0 1 3 0 0
`    *阈值分割，对S通道图像进行阈值分割，分割区域为0至100，分割结果为区域Region2 
阈值分割，对S通道图像进行阈值分割，分割区域为0至100，分割结果为区域Region2
threshold 1 1 2 0 1 1 0 0
`    threshold (ImageResult22, RegionT2,0,100)
ImageResult22
RegionT2
0
100
comment 0 0 1 0 1 3 0 0
`    *针对区域Region2进行腐蚀，腐蚀参数为3.5，参数值越大，腐蚀面积越大
针对区域Region2进行腐蚀，腐蚀参数为3.5，参数值越大，腐蚀面积越大
erosion_circle 1 1 1 0 1 1 0 0
`    erosion_circle (RegionT2, RegionErosionT2, 3.5)
RegionT2
RegionErosionT2
3.5
comment 0 0 1 0 1 3 0 0
`    *对腐蚀后的区域进行填充操作，使腐蚀出的不完整桌面填充为完整桌面
对腐蚀后的区域进行填充操作，使腐蚀出的不完整桌面填充为完整桌面
fill_up 1 1 0 0 1 1 0 0
`    fill_up (RegionErosionT2, RegionFillUpT2)
RegionErosionT2
RegionFillUpT2
comment 0 0 1 0 1 3 0 0
`    *区域联通。将不同的区域各自联通起来，作为形状选择的目标，不同区域用不同颜色表示
区域联通。将不同的区域各自联通起来，作为形状选择的目标，不同区域用不同颜色表示
connection 1 1 0 0 1 1 0 0
`    connection ( RegionFillUpT2, ConnectedRegionsT2)
RegionFillUpT2
ConnectedRegionsT2
comment 0 0 1 0 1 3 0 0
`    *选择桌面区域。因为桌子呈较大面积矩形，因此面积为40万到110万像素点，矩形度为0.6至1.
选择桌面区域。因为桌子呈较大面积矩形，因此面积为40万到110万像素点，矩形度为0.6至1.
select_shape 1 1 4 0 1 1 0 0
`    select_shape (ConnectedRegionsT2, SelectedRegionsT2, ['area','rectangularity'], 'and', [400000, 0.6], [1100000, 1])
ConnectedRegionsT2
SelectedRegionsT2
['area','rectangularity']
'and'
[400000, 0.6]
[1100000, 1]
comment 0 0 1 0 1 6 0 0
`    

comment 0 0 1 0 1 6 0 0
`    

comment 0 0 1 0 1 3 0 0
`    *右相机识别红色圆形目标
右相机识别红色圆形目标
comment 0 0 1 0 1 3 0 0
`    *提取桌面  将G通道的图像与桌面区域相减
提取桌面  将G通道的图像与桌面区域相减
reduce_domain 2 1 0 0 1 1 0 0
`    reduce_domain (Image22, SelectedRegionsT2, ImageReducedr2)
Image22
SelectedRegionsT2
ImageReducedr2
comment 0 0 1 0 1 3 0 0
`    *针对G通道进行阈值分割，分割范围为0~60
针对G通道进行阈值分割，分割范围为0~60
threshold 1 1 2 0 1 1 0 0
`    threshold (Image11, Regionr1,0,60) 
Image11
Regionr1
0
60
comment 0 0 1 0 1 3 0 0
`    *为填补阈值分割出的小孔，对分割结果进行膨胀，膨胀系数为2
为填补阈值分割出的小孔，对分割结果进行膨胀，膨胀系数为2
closing_circle 1 1 1 0 1 1 0 0
`    closing_circle (Regionr1, RegionClosingr1, 2)
Regionr1
RegionClosingr1
2
comment 0 0 1 0 1 3 0 0
`    *为将目标进一步与背景区分，对膨胀结果进行腐蚀，腐蚀系数为2
为将目标进一步与背景区分，对膨胀结果进行腐蚀，腐蚀系数为2
opening_circle 1 1 1 0 1 1 0 0
`    opening_circle (RegionClosingr1, RegionOpeningr1, 2)
RegionClosingr1
RegionOpeningr1
2
comment 0 0 1 0 1 3 0 0
`    *将第一次腐蚀结果的区域与H通道的结果相减，得到H通道一部分的区域图
将第一次腐蚀结果的区域与H通道的结果相减，得到H通道一部分的区域图
reduce_domain 2 1 0 0 1 1 0 0
`    reduce_domain (ImageResult11, RegionOpeningr1, ImageReducedgr1)
ImageResult11
RegionOpeningr1
ImageReducedgr1
comment 0 0 1 0 1 3 0 0
`    *再将该图进行第二次阈值分割，分割范围为0~70
再将该图进行第二次阈值分割，分割范围为0~70
threshold 1 1 2 0 1 1 0 0
`    threshold (ImageReducedgr1, Regionr2,0,70)
ImageReducedgr1
Regionr2
0
70
comment 0 0 1 0 1 3 0 0
`    *对二次分割图像再进行膨胀处理
对二次分割图像再进行膨胀处理
closing_circle 1 1 1 0 1 1 0 0
`    closing_circle (Regionr2, RegionClosingr2, 2)
Regionr2
RegionClosingr2
2
comment 0 0 1 0 1 3 0 0
`    *而后进行腐蚀处理
而后进行腐蚀处理
opening_circle 1 1 1 0 1 1 0 0
`    opening_circle (RegionClosingr2, RegionOpeningr2, 2)
RegionClosingr2
RegionOpeningr2
2
comment 0 0 1 0 1 3 0 0
`    *为填补可能出现的空洞，进行填充处理，最终得到红色的目标区域
为填补可能出现的空洞，进行填充处理，最终得到红色的目标区域
fill_up 1 1 0 0 1 1 0 0
`    fill_up (RegionOpeningr2, RegionFillUpr1)
RegionOpeningr2
RegionFillUpr1
connection 1 1 0 0 1 1 0 0
`    connection ( RegionFillUpr1, ConnectedRegions22)  
RegionFillUpr1
ConnectedRegions22
comment 0 0 1 0 1 3 0 0
`    *最终，通过面积与圆度的形状特征，得到红色圆形目标
最终，通过面积与圆度的形状特征，得到红色圆形目标
select_shape 1 1 4 0 1 1 0 0
`    select_shape (ConnectedRegions22, SelectedRegions_R, ['area','circularity'], 'and', [2000, 0.75], [11000, 1])
ConnectedRegions22
SelectedRegions_R
['area','circularity']
'and'
[2000, 0.75]
[11000, 1]
comment 0 0 1 0 1 6 0 0
`   

comment 0 0 1 0 1 3 0 0
`    *确定左右相机识别到的目标个数
确定左右相机识别到的目标个数
count_obj 1 0 0 1 1 1 0 0
`    count_obj (SelectedRegions_L, Number1)  
SelectedRegions_L
Number1
count_obj 1 0 0 1 1 1 0 0
`    count_obj (SelectedRegions_R, Number2) 
SelectedRegions_R
Number2
comment 0 0 1 0 1 6 0 0
    * 

ifelse 0 0 1 0 1 3 0 0
`     if (Number1=1 and Number2=1)
Number1=1 and Number2=1
comment 0 0 1 0 2 3 0 0
`        *读取内外参数文件
读取内外参数文件
read_cam_par 0 0 1 1 2 1 0 0
`        read_cam_par ('campar1.dat', CameraParameters1)
'campar1.dat'
CameraParameters1
read_cam_par 0 0 1 1 2 1 0 0
`        read_cam_par ('campar2.dat', CameraParameters2)
'campar2.dat'
CameraParameters2
read_pose 0 0 1 1 2 1 0 0
`        read_pose ('relpose.dat', RealPose)
'relpose.dat'
RealPose
comment 0 0 1 0 2 6 0 0
        * 

comment 0 0 1 0 2 3 0 0
`        *确定左相机识别到的目标在图像坐标系下的位置
确定左相机识别到的目标在图像坐标系下的位置
boundary 1 1 1 0 2 1 0 0
`        boundary (SelectedRegions_L, RegionBorder1, 'inner')
SelectedRegions_L
RegionBorder1
'inner'
gen_contour_region_xld 1 1 1 0 2 1 0 0
`        gen_contour_region_xld (RegionBorder1, Contours1, 'center')
RegionBorder1
Contours1
'center'
fit_ellipse_contour_xld 1 0 7 8 2 1 0 0
`        fit_ellipse_contour_xld (Contours1, 'fitzgibbon', -1, 0, 0, 200, 3, 2, Row1, Column1, Phi1, Radius11, Radius12, StartPhi1, EndPhi1, PointOrder1)
Contours1
'fitzgibbon'
-1
0
0
200
3
2
Row1
Column1
Phi1
Radius11
Radius12
StartPhi1
EndPhi1
PointOrder1
gen_ellipse_contour_xld 0 1 9 0 2 1 0 0
`        gen_ellipse_contour_xld (ContEllipse1, Row1, Column1, Phi1, Radius11, Radius12, 0, 6.28318, 'positive', 1.5)
ContEllipse1
Row1
Column1
Phi1
Radius11
Radius12
0
6.28318
'positive'
1.5
comment 0 0 1 0 2 3 0 0
`        *确定右相机识别到的目标在图像坐标系下的位置
确定右相机识别到的目标在图像坐标系下的位置
boundary 1 1 1 0 2 1 0 0
`        boundary (SelectedRegions_R, RegionBorder2, 'inner')
SelectedRegions_R
RegionBorder2
'inner'
gen_contour_region_xld 1 1 1 0 2 1 0 0
`        gen_contour_region_xld (RegionBorder2, Contours2, 'center')
RegionBorder2
Contours2
'center'
fit_ellipse_contour_xld 1 0 7 8 2 1 0 0
`        fit_ellipse_contour_xld (Contours2, 'fitzgibbon', -1, 0, 0, 200, 3, 2, Row2, Column2, Phi2, Radius21, Radius22, StartPhi2, EndPhi2, PointOrder2)
Contours2
'fitzgibbon'
-1
0
0
200
3
2
Row2
Column2
Phi2
Radius21
Radius22
StartPhi2
EndPhi2
PointOrder2
gen_ellipse_contour_xld 0 1 9 0 2 1 0 0
`        gen_ellipse_contour_xld (ContEllipse2, Row2, Column2, Phi2, Radius21, Radius22, 0, 6.28318, 'positive', 1.5)
ContEllipse2
Row2
Column2
Phi2
Radius21
Radius22
0
6.28318
'positive'
1.5
comment 0 0 1 0 2 6 0 0
` 

comment 0 0 1 0 2 3 0 0
`        *进行双目定位
进行双目定位
intersect_lines_of_sight 0 0 7 4 2 1 0 0
`        intersect_lines_of_sight (CameraParameters1, CameraParameters2, RealPose, Row1, Column1, Row2, Column2, X, Y, Z, Dist)
CameraParameters1
CameraParameters2
RealPose
Row1
Column1
Row2
Column2
X
Y
Z
Dist
comment 0 0 1 0 2 6 0 0
        * 

comment 0 0 1 0 2 3 0 0
`        *绘图显示
绘图显示
dev_set_window 0 0 1 0 2 2 0 0
`        dev_set_window (WindowHandle1)
WindowHandle1
dev_display 1 0 0 0 2 2 0 0
`        dev_display (Image1)
Image1
dev_set_color 0 0 1 0 2 2 0 0
`        dev_set_color ('red')
'red'
dev_set_line_width 0 0 1 0 2 2 0 0
`        dev_set_line_width (4)
4
gen_cross_contour_xld 0 1 4 0 2 1 0 0
`        gen_cross_contour_xld (Cross, Row1, Column1, 30, 0.785398)
Cross
Row1
Column1
30
0.785398
dev_display 1 0 0 0 2 2 0 0
`        dev_display (Cross)
Cross
dev_set_window 0 0 1 0 2 2 0 0
`        dev_set_window (WindowHandle2)
WindowHandle2
dev_display 1 0 0 0 2 2 0 0
`        dev_display (Image2)
Image2
dev_set_color 0 0 1 0 2 2 0 0
`        dev_set_color ('red')
'red'
dev_set_line_width 0 0 1 0 2 2 0 0
`        dev_set_line_width (4)
4
gen_cross_contour_xld 0 1 4 0 2 1 0 0
`        gen_cross_contour_xld (Cross, Row1, Column1, 30, 0.785398)
Cross
Row1
Column1
30
0.785398
dev_display 1 0 0 0 2 2 0 0
`        dev_display (Cross)
Cross
comment 0 0 1 0 2 6 0 0
`        

set_display_font 0 0 5 0 2 4 0 0
`        set_display_font (WindowHandle1, 15, 'mono', 'true', 'false')
WindowHandle1
15
'mono'
'true'
'false'
set_display_font 0 0 5 0 2 4 0 0
`        set_display_font (WindowHandle1, 20, 'mono', 'true', 'false')
WindowHandle1
20
'mono'
'true'
'false'
disp_message 0 0 7 0 2 4 0 0
`        disp_message (WindowHandle1, 'Found: OK', 'image', 0, 0, 'red', 'true')
WindowHandle1
'Found: OK'
'image'
0
0
'red'
'true'
set_display_font 0 0 5 0 2 4 0 0
`        set_display_font (WindowHandle1, 15, 'mono', 'true', 'false')
WindowHandle1
15
'mono'
'true'
'false'
disp_message 0 0 7 0 2 4 0 0
`        disp_message (WindowHandle1, 'Px='+X*1000+'mm\n''Py='+Y*1000+'mm\n''Pz='+Z*1000+' mm', 'image', 111, 0, 'black', 'true')   
WindowHandle1
'Px='+X*1000+'mm\n''Py='+Y*1000+'mm\n''Pz='+Z*1000+' mm'
'image'
111
0
'black'
'true'
comment 0 0 1 0 2 6 0 0
`   

else 0 0 0 0 1 3 109 0
`     else
dev_set_window 0 0 1 0 2 2 0 0
`         dev_set_window (WindowHandle1)
WindowHandle1
dev_display 1 0 0 0 2 2 0 0
`         dev_display (Image1)       
Image1
dev_set_window 0 0 1 0 2 2 0 0
`         dev_set_window (WindowHandle2)
WindowHandle2
dev_display 1 0 0 0 2 2 0 0
`         dev_display (Image2)  
Image2
set_display_font 0 0 5 0 2 4 0 0
`         set_display_font (WindowHandle1, 20, 'mono', 'true', 'false')
WindowHandle1
20
'mono'
'true'
'false'
disp_message 0 0 7 0 2 4 0 0
`         disp_message (WindowHandle1, 'LOST: Is finding', 'image', 0, 0, 'red', 'true')
WindowHandle1
'LOST: Is finding'
'image'
0
0
'red'
'true'
endif 0 0 0 0 1 3 149 0
`     endif
comment 0 0 1 0 1 6 0 0
    * 

endwhile 0 0 0 0 0 3 20 0
`endwhile
comment 0 0 1 0 0 6 0 0
* 

comment 0 0 1 0 0 3 0 0
`*关闭相机
关闭相机
close_framegrabber 0 0 1 0 0 1 0 0
`close_framegrabber (AcqHandle1)
AcqHandle1
close_framegrabber 0 0 1 0 0 1 0 0
`close_framegrabber (AcqHandle2)
AcqHandle2
comment 0 0 1 0 0 6 0 0
* 

comment 0 0 1 0 0 6 0 0
* 

